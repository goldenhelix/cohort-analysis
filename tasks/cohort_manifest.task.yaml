# We could point this to our public schema?
# yaml-language-server: $schema=https://www.schemastore.org/any.json
name: Cohort Manifest Generator
description: |-
  Creates a manifest file listing all VCF.gz files from an input directory.

  This task generates a manifest file that lists all VCF.gz files in a specified
  directory. The manifest file is used to specify the input files for downstream
  tasks that require a list of VCF files.

  ## Important Note
  This task should not be run directly. Instead:
  1. Use the "Build Cohort Annotation Track" workflow
  2. Select your existing cohort parameter file
  3. Select the folder containing your new VCF files
  
  The workflow will automatically run this task as part of the cohort workflow.

agent_requirements:
  cpu_cores: 0
  memory_gb: 0

parameters:
  - name: input_directory
    type: directory
    label: Input Directory
    help: Directory containing VCF.gz files to process
    supports_location_mode: 'read_only'

  - name: parameter_file
    type: file
    label: Parameter File
    help: The cohort parameter file for the cohort being updated

  - name: existing_counts
    type: file
    label: Existing Counts File
    help: Optional TSF file containing existing variant counts to update
    pattern_match: ["*.tsf"]
    optional: true

steps:
  - name: create_manifest
    description: Create manifest file listing all VCF.gz files
    type: cmd
    command: bash
    args:
      - |- # shell
        #!/usr/bin/env bash
        set -e

        gautil_path="/opt/apiserver/gautil"

        # Ensure output directory exists
        output_directory="$(pwd)"
        mkdir -p "${output_directory}"

        if [ -z "${existing_counts}" ]; then
          out_file=$(grep "out_file=" "${parameter_file}" | cut -d '=' -f 2)
          out_file="${WORKSPACE_DIR}/${out_file}"
          out_file="${out_file%.tsf}"
          existing_counts=$(ls -t "${out_file}"_*.tsf 2>/dev/null | head -n 1)
        fi

        existing_sample_names="samples.txt"
        if [ ! -z "${existing_counts}" ]; then
          echo "Using existing counts file: ${existing_counts}"

          cat <<EOF > sample_names.txsource
          {
            "inputs": [
              "${existing_counts}:2"
            ],
            "name": "entitiesAsFeatures",
            "options": {
              "className": "EntitiesAsFeaturesTransformOptions"
            }
          }

        EOF
          "${gautil_path}" read sample_names.txsource | cut -f 5 > "${existing_sample_names}"
          echo "Extracted $(wc -l < existing_sample_names) sample names from existing counts file."
        else
          echo "No existing counts file provided or found."
          touch "${existing_sample_names}"
        fi

        python3 "${TASK_DIR}/../scripts/create_manifest_files.py" -n 256 "${existing_sample_names}" "${input_directory}" 

        # Seem to need this to prevent I/O errors on windows ???, otherwise we
        # can't write the result.env file
        echo "Working directory: $(pwd)/.., contains $(ls -la ../.)"


        parameter_file="${output_directory}/parameter_file.csv"
        parameter_file="$(readlink -f "${parameter_file}")"
        parameter_file="${parameter_file#${WORKSPACE_DIR}/}"

        output_directory="$(pwd)"
        output_directory="${output_directory#${WORKSPACE_DIR}/}"

        output_manifest_list="$(pwd)/manifest_list.csv"
        output_manifest_list="${output_manifest_list#${WORKSPACE_DIR}/}"

        touch result.env
        echo "output_manifest_list=${output_manifest_list}" > result.env
        echo "output_directory=${output_directory}" >> result.env
        echo "Output Parameters:"
        cat result.env

